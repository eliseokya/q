import Time.Category
import Mathlib.CategoryTheory.Sieve

/-!
Interval-style covering predicate on `Timeáµ’áµ–`.
For objects `t : â„•áµ’áµ–`, a sieve `S` covers if for every `s â‰¤ t` there is a
morphism `f : s âŸ¶ t` in `S`.  This file introduces the predicate and proves
that the maximal sieve is covering (`top_mem`).  Pullback-stability and
transitivity will be added in later micro-steps.
-/

open CategoryTheory Opposite

namespace Time.Interval

/-- Predicate: sieve `S` covers `t` if it contains every arrow `s âŸ¶ t`. -/
@[simp]
def covers (t : Opposite â„•) (S : Sieve t) : Prop :=
  âˆ€ â¦ƒsâ¦„ (f : s âŸ¶ t), f âˆˆ S

lemma top_mem (t : Opposite â„•) : covers t (Sieve.top _) := by
  intro s f; simp 

lemma pullback_stable {t s : Opposite â„•} (f : s âŸ¶ t)
   {S : Sieve t} (hS : covers t S) :
   covers s (S.pullback f) := by
   intro s' g; 
   -- g : s' âŸ¶ s, need to show in pullback
   -- composition g â‰« f : s' âŸ¶ t
   have : (g â‰« f : s' âŸ¶ t) âˆˆ S := by
     apply hS
   -- by definition of pullback
   simpa using this 

lemma cover_superset {t : Opposite â„•} {S T : Sieve t}
    (hS : covers t S) (hST : S â‰¤ T) : covers t T := by
  intro s f
  apply hST
  exact hS f 

lemma covers_bind {t : Opposite â„•} {S : Sieve t}
    {R : âˆ€ {s : Opposite â„•}, (s âŸ¶ t) â†’ Sieve s}
    (hS : covers t S)
    (hR : âˆ€ {s} (f : s âŸ¶ t), f âˆˆ S â†’ covers s (R f)) :
    covers t (S.bind R) := by
  intro u g
  -- hf : g âˆˆ S since S covers t
  have hf : (g : u âŸ¶ t) âˆˆ S := hS g
  -- identity arrow in R g since R g covers u
  have h_id : (ğŸ™ u : u âŸ¶ u) âˆˆ R g := by
    have hcover := hR g hf
    simpa using hcover (ğŸ™ u)
  -- Provide witnesses to show g âˆˆ S.bind R via mem_bind equivalence
  have : (g : u âŸ¶ t) âˆˆ S.bind R := by
    -- witnesses f = g, h = ğŸ™
    have : (âˆƒ (f : _), f âˆˆ S âˆ§ âˆƒ (h : _), h âˆˆ R f âˆ§ (g : u âŸ¶ t) = h â‰« f) := by
      refine âŸ¨g, hf, ?_âŸ©
      refine âŸ¨(ğŸ™ u), h_id, ?_âŸ©
      simp
    simpa [mem_bind] using this
  simpa using this 

/-- Membership in `S.bind R` is by definition the existence of a factorisation
through `S` and the corresponding sieve in `R`.  This is just `rfl` unpacking
mathlibâ€™s definition, provided here for convenience. -/
@[simp]
lemma mem_bind {t : Opposite â„•} {S : Sieve t}
    {R : âˆ€ {s : Opposite â„•}, (s âŸ¶ t) â†’ Sieve s}
    {s : Opposite â„•} {g : s âŸ¶ t} :
    g âˆˆ S.bind R â†” âˆƒ (f : _), f âˆˆ S âˆ§ âˆƒ (h : _), h âˆˆ R f âˆ§ g = h â‰« f := by
  rfl 

/-- Interval Grothendieck topology on `Timeáµ’áµ–` generated by `covers`. -/
noncomputable def Ï„_interval : GrothendieckTopology (Opposite â„•) :=
{ sieves := covers,
  top_mem' := by
    intro U; apply top_mem,
  pullback_stable' := by
    intro U S hS s f; exact pullback_stable f hS,
  transitive' := by
    intro U S hS R hR
    -- Use covers_bind lemma
    have : covers U (S.bind R) :=
      covers_bind hS (by
        intro s f hf;
        exact hR f hf)
    exact this } 