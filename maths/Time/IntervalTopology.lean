import Time.Category
import Mathlib.CategoryTheory.Sieve

/-!
Interval-style covering predicate on `Timeᵒᵖ`.
For objects `t : ℕᵒᵖ`, a sieve `S` covers if for every `s ≤ t` there is a
morphism `f : s ⟶ t` in `S`.  This file introduces the predicate and proves
that the maximal sieve is covering (`top_mem`).  Pullback-stability and
transitivity will be added in later micro-steps.
-/

open CategoryTheory Opposite

namespace Time.Interval

/-- Predicate: sieve `S` covers `t` if it contains every arrow `s ⟶ t`. -/
@[simp]
def covers (t : Opposite ℕ) (S : Sieve t) : Prop :=
  ∀ ⦃s⦄ (f : s ⟶ t), f ∈ S

lemma top_mem (t : Opposite ℕ) : covers t (Sieve.top _) := by
  intro s f; simp 

lemma pullback_stable {t s : Opposite ℕ} (f : s ⟶ t)
   {S : Sieve t} (hS : covers t S) :
   covers s (S.pullback f) := by
   intro s' g; 
   -- g : s' ⟶ s, need to show in pullback
   -- composition g ≫ f : s' ⟶ t
   have : (g ≫ f : s' ⟶ t) ∈ S := by
     apply hS
   -- by definition of pullback
   simpa using this 

lemma cover_superset {t : Opposite ℕ} {S T : Sieve t}
    (hS : covers t S) (hST : S ≤ T) : covers t T := by
  intro s f
  apply hST
  exact hS f 

lemma covers_bind {t : Opposite ℕ} {S : Sieve t}
    {R : ∀ {s : Opposite ℕ}, (s ⟶ t) → Sieve s}
    (hS : covers t S)
    (hR : ∀ {s} (f : s ⟶ t), f ∈ S → covers s (R f)) :
    covers t (S.bind R) := by
  intro u g
  -- hf : g ∈ S since S covers t
  have hf : (g : u ⟶ t) ∈ S := hS g
  -- identity arrow in R g since R g covers u
  have h_id : (𝟙 u : u ⟶ u) ∈ R g := by
    have hcover := hR g hf
    simpa using hcover (𝟙 u)
  -- Provide witnesses to show g ∈ S.bind R via mem_bind equivalence
  have : (g : u ⟶ t) ∈ S.bind R := by
    -- witnesses f = g, h = 𝟙
    have : (∃ (f : _), f ∈ S ∧ ∃ (h : _), h ∈ R f ∧ (g : u ⟶ t) = h ≫ f) := by
      refine ⟨g, hf, ?_⟩
      refine ⟨(𝟙 u), h_id, ?_⟩
      simp
    simpa [mem_bind] using this
  simpa using this 

/-- Membership in `S.bind R` is by definition the existence of a factorisation
through `S` and the corresponding sieve in `R`.  This is just `rfl` unpacking
mathlib’s definition, provided here for convenience. -/
@[simp]
lemma mem_bind {t : Opposite ℕ} {S : Sieve t}
    {R : ∀ {s : Opposite ℕ}, (s ⟶ t) → Sieve s}
    {s : Opposite ℕ} {g : s ⟶ t} :
    g ∈ S.bind R ↔ ∃ (f : _), f ∈ S ∧ ∃ (h : _), h ∈ R f ∧ g = h ≫ f := by
  rfl 

/-- Interval Grothendieck topology on `Timeᵒᵖ` generated by `covers`. -/
noncomputable def τ_interval : GrothendieckTopology (Opposite ℕ) :=
{ sieves := covers,
  top_mem' := by
    intro U; apply top_mem,
  pullback_stable' := by
    intro U S hS s f; exact pullback_stable f hS,
  transitive' := by
    intro U S hS R hR
    -- Use covers_bind lemma
    have : covers U (S.bind R) :=
      covers_bind hS (by
        intro s f hf;
        exact hR f hf)
    exact this } 